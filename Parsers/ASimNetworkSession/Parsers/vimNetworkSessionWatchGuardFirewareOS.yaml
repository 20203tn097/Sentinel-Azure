Parser:
  Title: Network Session ASIM parser for WatchGuard Fireware OS
  Version: '0.1.0'
  LastUpdated: Aug 10th, 2022
Product:
  Name: WatchGuard Fireware OS
Normalization:
  Schema: NetworkSession
  Version: '0.2.4'
References:
  - Title: ASIM Network Session Schema
    Link: https://aka.ms/ASimNetworkSessionDoc
  - Title: ASIM
    Link: https://aka.ms/AboutASIM
  - Title: WatchGuard Help Center
    Link: https://www.watchguard.com/help/docs/help-center/en-US/Content/en-US/Fireware/_intro/fireware_help_front.html?tocpath=Fireware%7C_____0
Description: |
  This ASIM parser supports filtering and normalizing WatchGuard Fireware OS logs produced by the Microsoft Sentinel Syslog connector to the ASIM Network Session normalized schema.
ParserName: vimNetworkSessionWatchGuardFirewareOS                                  
EquivalentBuiltInParser: _Im_NetworkSession_WatchGuardFirewareOS                                  
ParserParams:
  - Name: starttime
    Type: datetime
    Default: datetime(null)
  - Name: endtime
    Type: datetime
    Default: datetime(null)
  - Name: srcipaddr_has_any_prefix
    Type: dynamic
    Default: dynamic([])
  - Name: dstipaddr_has_any_prefix
    Type: dynamic
    Default: dynamic([])
  - Name: ipaddr_has_any_prefix
    Type: dynamic
    Default: dynamic([])
  - Name: dstportnumber
    Type: int
    Default: int(null)
  - Name: hostname_has_any
    Type: dynamic
    Default: dynamic([])
  - Name: dvcaction
    Type: dynamic
    Default: dynamic([])
  - Name: eventresult
    Type: string
    Default: '*'
  - Name: disabled
    Type: bool
    Default: false
ParserQuery: |
  let EventLookup=datatable(DvcAction:string,EventResult:string,EventSeverity:string)
  [
      "Allow","Success","Informational"
      , "Deny","Failure","Low"
  ];
  let src_or_any=set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
  let dst_or_any=set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix); 
  let Parser=(starttime:datetime=datetime(null), endtime:datetime=datetime(null), srcipaddr_has_any_prefix:dynamic=dynamic([]), dstipaddr_has_any_prefix:dynamic=dynamic([]), ipaddr_has_any_prefix:dynamic=dynamic([]), dstportnumber:int=int(null), hostname_has_any:dynamic=dynamic([]), dvcaction:dynamic=dynamic([]), eventresult:string='*', disabled:bool=false){
  let AllLogs = Syslog
  | where not(disabled)
  | where (isnull(starttime) or TimeGenerated>=starttime) and (isnull(endtime) or TimeGenerated<=endtime)
  | where SyslogMessage has_any('msg_id="3000-0148"' 
      , 'msg_id="3000-0149"' 
      , 'msg_id="3000-0150"'
      , 'msg_id="3000-0151"'
      , 'msg_id="3000-0173"'
  )
  | project TimeGenerated, SyslogMessage, HostName;
  let WithFQDN = AllLogs
  | where SyslogMessage has "fqdn_dst_match=" and SyslogMessage !has "3000-0151"
  | parse kind=regex flags=U SyslogMessage with * @'msg_id="' MessageID @'"\sfqdn_dst_match="' DstDomain @'"\s' DvcAction @"\s" RuleName @"\s\d{2,5}\s" NetworkProtocol @"\s\d+\s\d+\s" SourceIP @"\s" DestinationIP @"\s" SrcPortNumber @"\s" DestinationPort @"\s" *
  | where  (isnull(dstportnumber) or DestinationPort==dstportnumber)
  | extend temp_SrcMatch=has_any_ipv4_prefix(SourceIP,src_or_any)
  , temp_DstMatch=has_any_ipv4_prefix(DestinationIP,dst_or_any)
  | extend ASimMatchingIpAddr=case(
    array_length(src_or_any) == 0 and array_length(dst_or_any) == 0 ,"-",
    temp_SrcMatch and temp_DstMatch, "Both",
    temp_SrcMatch, "SrcIpAddr",
    temp_DstMatch, "DstIpAddr",
    "No match"
  )
  | where ASimMatchingIpAddr != "No match" 
  | project-away temp_*
  | extend DstDomainType = iif(isnotempty(DstDomain),"FQDN","")
  ;
  let WithoutFQDN = AllLogs
  | where SyslogMessage !has "fqdn_dst_match=" and SyslogMessage !has "3000-0151"
  | parse kind=regex flags=U SyslogMessage with * @'msg_id="' MessageID @'"\s' DvcAction @"\s" RuleName @"\s\d{2,5}\s" NetworkProtocol @"\s\d+\s\d+\s" SourceIP @"\s" DestinationIP @"\s" SrcPortNumber @"\s" DestinationPort @"\s" *
  | where  (isnull(dstportnumber) or DestinationPort==dstportnumber)
  | extend temp_SrcMatch=has_any_ipv4_prefix(SourceIP,src_or_any)
  , temp_DstMatch=has_any_ipv4_prefix(DestinationIP,dst_or_any)
  | extend ASimMatchingIpAddr=case(
    array_length(src_or_any) == 0 and array_length(dst_or_any) == 0 ,"-",
    temp_SrcMatch and temp_DstMatch, "Both",
    temp_SrcMatch, "SrcIpAddr",
    temp_DstMatch, "DstIpAddr",
    "No match"
  )
  | where ASimMatchingIpAddr != "No match" 
  | project-away temp_*
  ;
  let WithPortDuration = AllLogs
  | where SyslogMessage has "3000-0151" and SyslogMessage !has "icmp"
  | parse kind=regex flags=U SyslogMessage with * @'msg_id="' MessageID @'"\s' DvcAction @"\s" RuleName @"\s(tcp|udp|icmp|igmp)\s" SourceIP @"\s" DestinationIP @"\s" SrcPortNumber @"\s" DestinationPort @'\sduration="' NetworkDuration:int @'"\ssent_bytes="' SrcBytes:long @'"\srcvd_bytes="' DstBytes:long '"' *
  | where  (isnull(dstportnumber) or DestinationPort==dstportnumber)
  | extend temp_SrcMatch=has_any_ipv4_prefix(SourceIP,src_or_any)
  , temp_DstMatch=has_any_ipv4_prefix(DestinationIP,dst_or_any)
  | extend ASimMatchingIpAddr=case(
    array_length(src_or_any) == 0 and array_length(dst_or_any) == 0 ,"-",
    temp_SrcMatch and temp_DstMatch, "Both",
    temp_SrcMatch, "SrcIpAddr",
    temp_DstMatch, "DstIpAddr",
    "No match"
  )
  | where ASimMatchingIpAddr != "No match" 
  | project-away temp_*
  | extend NetworkProtocol = extract(@"\s(tcp|udp|icmp|igmp)\s", 1, SyslogMessage)
  ;
  let ICMP = AllLogs
  | where SyslogMessage has "3000-0151" and SyslogMessage has "icmp"
  | parse kind=regex flags=U SyslogMessage with * @'msg_id="' MessageID @'"\s' DvcAction @"\s" RuleName @"\s(tcp|udp|icmp|igmp)\s" SourceIP @"\s" DestinationIP @'\sduration="' NetworkDuration:int @'"\ssent_bytes="' SrcBytes:long @'"\srcvd_bytes="' DstBytes:long '"' *
  | extend temp_SrcMatch=has_any_ipv4_prefix(SourceIP,src_or_any)
  , temp_DstMatch=has_any_ipv4_prefix(DestinationIP,dst_or_any)
  | extend ASimMatchingIpAddr=case(
    array_length(src_or_any) == 0 and array_length(dst_or_any) == 0 ,"-",
    temp_SrcMatch and temp_DstMatch, "Both",
    temp_SrcMatch, "SrcIpAddr",
    temp_DstMatch, "DstIpAddr",
    "No match"
  )
  | where ASimMatchingIpAddr != "No match" 
  | project-away temp_*
  | extend NetworkProtocol = extract(@"\s(tcp|udp|icmp|igmp)\s", 1, SyslogMessage);
  union WithFQDN, WithoutFQDN, WithPortDuration, ICMP
  | lookup EventLookup on DvcAction
  | where  (array_length(hostname_has_any)==0) and (eventresult=="*" or (DvcAction=="Allow" and eventresult=="Success") or (eventresult=="Failure"))
  | where (array_length(dvcaction)==0 or DvcAction has_any (dvcaction))
  | parse SyslogMessage with * 'geo_src="' SrcGeoCountry '"' *
  | parse SyslogMessage with * 'geo_dst="' DstGeoCountry '"' *
  | parse SyslogMessage with * 'src_user="' SrcUsername '"' *
  | extend SrcUsernameType = iif(SrcUsername has "@","UPN","")
  | parse SyslogMessage with * 'dst_user="' DstUsername '"' *
  | extend DstUsernameType = iif(DstUsername has "@","UPN","")
  | parse SyslogMessage with * "repeated " EventCount:int " times" *
  | extend EventCount = iif(isnotempty(EventCount), EventCount, toint(1))
  | extend EventSchema = "NetworkSession"
    , EventSchemaVersion = "0.2.4"
    , EventVendor = "WatchGuard"
    , EventProduct = "Fireware"
    , EventType = "NetworkSession"
    , DvcHostname = HostName
    , NetworkProtocolVersion = case(DestinationIP contains ".", "IPv4"
        , DestinationIP contains ":", "IPv6"
        , "")
    , NetworkProtocol = toupper(NetworkProtocol)
    , NetworkDuration = NetworkDuration * toint(1000)
    , NetworkBytes = SrcBytes + DstBytes
    , EventEndTime = TimeGenerated
    , EventStartTime = TimeGenerated
  | project-rename Dvc = HostName
    , SrcIpAddr = SourceIP
    , DstIpAddr = DestinationIP
    , DstPortNumber = DestinationPort
  };
  Parser (starttime=starttime, endtime=endtime, srcipaddr_has_any_prefix=srcipaddr_has_any_prefix, dstipaddr_has_any_prefix=dstipaddr_has_any_prefix, ipaddr_has_any_prefix=ipaddr_has_any_prefix, dstportnumber=dstportnumber, hostname_has_any=hostname_has_any, dvcaction=dvcaction, eventresult=eventresult, disabled=disabled)
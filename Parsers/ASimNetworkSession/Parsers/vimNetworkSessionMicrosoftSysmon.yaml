Parser:
  Title:  Network Session Event ASIM filtering parser for Sysmon (Event 3)
  Version: '0.0.2'
  LastUpdated: Dec 29, 2022
Product:
  Name: Windows Sysmon
Normalization:
  Schema: NetworkSession
  Version: '0.2.4'
References:
- Title: ASIM Network Session Schema
  Link: https://aka.ms/ASimNetworkSessionDoc
- Title: ASIM
  Link: https:/aka.ms/AboutASIM
Description: |
  This ASIM parser supports filtering and normalizing Sysmon network session events (event 3) collected using the Event or WEF (WindowsEvent table) connectors to the ASIM Process Event normalized schema. 
ParserName: vimNetworkSessionMicrosoftSysmon
EquivalentBuiltInParser: _Im_NetworkSession_MicrosoftSysmon
ParserParams:
  - Name: starttime
    Type: datetime
    Default: datetime(null)
  - Name: endtime
    Type: datetime
    Default: datetime(null)
  - Name: srcipaddr_has_any_prefix
    Type: dynamic
    Default: dynamic([])
  - Name: dstipaddr_has_any_prefix
    Type: dynamic
    Default: dynamic([])
  - Name: ipaddr_has_any_prefix
    Type: dynamic
    Default: dynamic([])
  - Name: dstportnumber
    Type: int
    Default: int(null)
  - Name: hostname_has_any
    Type: dynamic
    Default: dynamic([])
  - Name: dvcaction
    Type: dynamic
    Default: dynamic([])
  - Name: eventresult
    Type: string
    Default: '*'
  - Name: disabled
    Type: bool
    Default: false
ParserQuery: |
  let src_or_any=set_union(srcipaddr_has_any_prefix, ipaddr_has_any_prefix); 
  let dst_or_any=set_union(dstipaddr_has_any_prefix, ipaddr_has_any_prefix); 
  let ip_any = set_union(srcipaddr_has_any_prefix, dstipaddr_has_any_prefix, ipaddr_has_any_prefix);
  let Sysmon3_NetworkEvent =    
      Event
      | where (isnull(starttime) or TimeGenerated>=starttime)
        and (isnull(endtime) or TimeGenerated<=endtime) 
      | where not(disabled)
      | where Source == "Microsoft-Windows-Sysmon" and EventID==3
      | project-away ParameterXml, RenderedDescription
      // ***************  Prefilterring *****************************************************************
      | where  
              (array_length(dvcaction) ==0  )     /// if filtered by action return nothing
          and (array_length(ip_any)==0 
               or has_any_ipv4_prefix(EventData,ip_any)
               ) 
          and (array_length(hostname_has_any)==0 
               or EventData has_any(hostname_has_any))  // can we not just check on "Computer" in this case? I took this from the Linux Sysmon example
          and (isnull(dstportnumber) or EventData has (tostring(dstportnumber))) 
      // ***************  Prefilterring *****************************************************************   
       | parse-kv EventData as 
        (
          SourceIp:string,
          DestinationIp:string,
          SourceHostname:string,
          DestinationHostname:string,
          Initiated:bool  // Initiated indicates the process initiated a connection (meaning outbound)
         ) 
          with (regex=@'<Data Name="(\w+)">{?([^>]*)}?</Data>')    
      | project-rename
        SrcIpAddr = SourceIp,
        DstIpAddr = DestinationIp,
        SrcHostname = SourceHostname,
        DstHostname = DestinationHostname
      | where 
        (array_length(srcipaddr_has_any_prefix)==0 
                      or has_any_ipv4_prefix(SrcIpAddr,srcipaddr_has_any_prefix)
        )
      ;    
  let Sysmon3_NetworkWindowsEvent =    
  WindowsEvent
    | where (isnull(starttime) or TimeGenerated>=starttime) and (isnull(endtime) or TimeGenerated<=endtime) 
    | where not(disabled)
    | where Provider == "Microsoft-Windows-Sysmon" and EventID == 3
    // ***************  Prefilterring *****************************************************************
    | where  (array_length(dvcaction) ==0  )     /// if filtered by action return nothing
            and (array_length(ip_any)==0 
                  or has_any_ipv4_prefix(EventData,ip_any)
                ) 
           and (array_length(hostname_has_any)==0 
                  or EventData has_any(hostname_has_any))  // can we not just check on "Computer" in this case? I took this from the Linux Sysmon example
            and (isnull(dstportnumber) or EventData has (tostring(dstportnumber))) 
    // ***************  Prefilterring *****************************************************************   
    | extend
            SrcIpAddr = tostring(EventData.SourceIp),
            DstIpAddr = tostring(EventData.DestinationIp),
            DstHostname = tostring(EventData.DestinationHostname),
            SrcHostname = tostring(EventData.SrcHostname),
            Initiated = tobool(EventData.Initiated)
    | extend 
    SourceIsInternal = iff (
          ipv4_is_private(SrcIpAddr) , "true", "false")
    | extend 
    DestinationIsInternal = iff (
          ipv4_is_private(DstIpAddr) , "true", "false")  // this works only on ipv4 and on RFC standard internal Ips
    ;
    let EventParser = (T: (EventData: string)) {
    T 
    | parse-kv EventData as 
          (
          ProcessGuid:string,
          ProcessId:string,
          Image:string,
          User:string,
          Protocol:string,
          Initiated:bool,
          RuleName:string,
          SourceIsIpv6:bool,
          SourcePort:int,
          DestinationIsIpv6:bool,
          DestinationIp:string,
          DestinationPort:int,
          SourceHostname:string,
          DestinationHostname:string,
          UtcTime:datetime
          ) 
          with (regex=@'<Data Name="(\w+)">{?([^>]*)}?</Data>')
    | project-away EventData
    | project-rename
         SrcPortNumber = SourcePort,
         DstPortNumber = DestinationPort,
         EventStartTime = UtcTime
    | extend
         NetworkProtocolVersion = iff((SourceIsIpv6 or DestinationIsIpv6), "IPv6", "IPv4")
    | project-away
        SourceIsIpv6, DestinationIsIpv6
    | extend 
                ProcessGuid = tostring(split(split(ProcessGuid, "{")[-1], "}")[0])    
    };
    let OutboundNetworkEvents = 
    Sysmon3_NetworkEvent
    | where Source == "Microsoft-Windows-Sysmon" and EventID==3 // we want to ensure we only have the Event table and not the WindowsEvent table
    | where Initiated
    | extend NetworkDirection = "Outbound"
    | invoke EventParser ()
    | extend 
             temp_isSrcMatch=has_any_ipv4_prefix(SrcIpAddr,src_or_any) 
           , temp_isDstMatch=has_any_ipv4_prefix(DstIpAddr,dst_or_any)
    | extend 
    ASimMatchingIpAddr = case(
            array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, "-" // match not requested: probably most common case
            , (temp_isSrcMatch and temp_isDstMatch), "Both" // has to be checked before the individual 
            , temp_isSrcMatch, "SrcIpAddr"
            , temp_isDstMatch, "DstIpAddr"
            , "No match"
    )
    | where ASimMatchingIpAddr != "No match"
    | extend 
    temp_isSrcHostMatch= (SrcHostname has_any (hostname_has_any))
            , temp_isDstHostMatch = (DstHostname has_any (hostname_has_any))
    | extend ASimMatchingHostname = case(
            array_length(hostname_has_any) == 0, "-" // match not requested: probably most common case
            , (temp_isSrcHostMatch and temp_isDstHostMatch), "Both" // has to be checked before the individual 
            , temp_isSrcHostMatch, "SrcHostname"
            , temp_isDstHostMatch, "DstHostname"
            , "No match"
    )
    | where ASimMatchingHostname != "No match"
    | project-away temp_*
    | extend 
        SrcUsernameType = 'Simple',
        SrcProcessName = tostring(Image),
        SrcAppName = tostring(Image),
        SrcAppType = 'Process',
        SrcUsername = tostring(User), 
        SrcProcessId = tostring(ProcessId),
        SrcProcessGuid = ProcessGuid
    | project-away
     Image, Initiated
    ;
    let InboundNetworkEvents = 
    Sysmon3_NetworkEvent
    | where Source == "Microsoft-Windows-Sysmon" and EventID==3 // we want to ensure we only have the Event table and not the WindowsEvent table
    | where not(Initiated)
    | extend NetworkDirection = "Inbound"
    | invoke EventParser ()
    | extend 
             temp_isSrcMatch=has_any_ipv4_prefix(SrcIpAddr,src_or_any) 
           , temp_isDstMatch=has_any_ipv4_prefix(DstIpAddr,dst_or_any)
    | extend ASimMatchingIpAddr = case(
            array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, "-" // match not requested: probably most common case
            , (temp_isSrcMatch and temp_isDstMatch), "Both" // has to be checked before the individual 
            , temp_isSrcMatch, "SrcIpAddr"
            , temp_isDstMatch, "DstIpAddr"
            , "No match"
    )
    | where ASimMatchingIpAddr != "No match"
    | extend temp_isSrcHostMatch= (SrcHostname has_any (hostname_has_any))
            , temp_isDstHostMatch = (DstHostname has_any (hostname_has_any))
    | extend ASimMatchingHostname = case(
            array_length(hostname_has_any) == 0, "-" // match not requested: probably most common case
            , (temp_isSrcHostMatch and temp_isDstHostMatch), "Both" // has to be checked before the individual 
            , temp_isSrcHostMatch, "SrcHostname"
            , temp_isDstHostMatch, "DstHostname"
            , "No match"
    )
    | where ASimMatchingHostname != "No match"
    | project-away temp_*
    | extend 
        DstUsernameType = 'Simple',
        DstUsername = tostring(User),
        DstProcessId = tostring(ProcessId),
        DstProcessName = tostring(Image),
        DstProcessGuid = ProcessGuid,
        DstAppName = tostring(Image),
        DstAppType = 'Process'
    | project-away
     Image, Initiated
    ;
    let WindowsEventParser = (T: (EventData: dynamic)) {
      T       
    | extend 
            ProcessGuid = tostring(EventData.ProcessGuid),
            ProcessId = tostring(EventData.ProcessId),
            Image = tostring(EventData.Image),
            User = tostring(EventData.User),
            Protocol = tostring(EventData.Protocol),
            Initiated = tobool(EventData.Initiated),
            SourceIsIpv6 = tobool(EventData.SourceIsIpv6),
            SourcePort = toint(EventData.SourcePort),
            DestinationIsIpv6 = tobool(EventData.DestinationIsIpv6),
            DstPortNumber = toint(EventData.DestinationPort),
            EventStartTime = todatetime(EventData.UtcTime),
            RuleName = tostring(EventData.RuleName)
    | project-away EventData
    | extend
         ProcessGuid = tostring(split(split(ProcessGuid, "{")[-1], "}")[0]),
         NetworkProtocolVersion = iff((SourceIsIpv6 or DestinationIsIpv6), "IPv6", "IPv4")
    | project-rename
    SrcPortNumber = SourcePort
    | project-away
            SourceIsIpv6, DestinationIsIpv6
         };
    let OutboundNetworkWindowsEvents = 
    Sysmon3_NetworkWindowsEvent
    | where Provider == "Microsoft-Windows-Sysmon" and EventID == 3 // we want to ensure this only applies to WindowsEvents
    | where Initiated
    | extend NetworkDirection = "Outbound"
    | invoke WindowsEventParser ()
          | extend 
             temp_isSrcMatch=has_any_ipv4_prefix(SrcIpAddr,src_or_any) 
           , temp_isDstMatch=has_any_ipv4_prefix(DstIpAddr,dst_or_any)
    | extend ASimMatchingIpAddr = case(
            array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, "-" // match not requested: probably most common case
            , (temp_isSrcMatch and temp_isDstMatch), "Both" // has to be checked before the individual 
            , temp_isSrcMatch, "SrcIpAddr"
            , temp_isDstMatch, "DstIpAddr"
            , "No match"
    )       
     | where ASimMatchingIpAddr != "No match"
     | extend temp_isSrcHostMatch= (SrcHostname has_any (hostname_has_any))
            , temp_isDstHostMatch = (DstHostname has_any (hostname_has_any))
     | extend ASimMatchingHostname = case(
            array_length(hostname_has_any) == 0, "-" // match not requested: probably most common case
            , (temp_isSrcHostMatch and temp_isDstHostMatch), "Both" // has to be checked before the individual 
            , temp_isSrcHostMatch, "SrcHostname"
            , temp_isDstHostMatch, "DstHostname"
            , "No match"
    )
    | where ASimMatchingHostname != "No match"
    | project-away temp_* 
    | extend 
        SrcUsernameType = 'Simple',
        SrcAppName = tostring(Image),
        SrcAppType = 'Process',
        SrcUsername = tostring(User),
        SrcProcessId =  tostring(ProcessId),
        SrcProcessGuid = ProcessGuid,
        SrcProcessName = tostring(Image)
    | project-away
     Image, Initiated
      ;
  let  inboundNetworkWindowsEvents = 
  Sysmon3_NetworkWindowsEvent
    | where Provider == "Microsoft-Windows-Sysmon" and EventID == 3 // we want to ensure this only applies to WindowsEvents
    | where not(Initiated)
    | extend NetworkDirection = "Inbound"
    | invoke WindowsEventParser ()
          | extend 
             temp_isSrcMatch=has_any_ipv4_prefix(SrcIpAddr,src_or_any) 
           , temp_isDstMatch=has_any_ipv4_prefix(DstIpAddr,dst_or_any)
    | extend ASimMatchingIpAddr = case(
            array_length(src_or_any) == 0 and array_length(dst_or_any) == 0, "-" // match not requested: probably most common case
            , (temp_isSrcMatch and temp_isDstMatch), "Both" // has to be checked before the individual 
            , temp_isSrcMatch, "SrcIpAddr"
            , temp_isDstMatch, "DstIpAddr"
            , "No match"
    )       
    | where ASimMatchingIpAddr != "No match"
    | extend  temp_isSrcHostMatch= (SrcHostname has_any (hostname_has_any))
            , temp_isDstHostMatch = (DstHostname has_any (hostname_has_any))
    | extend  ASimMatchingHostname = case(
            array_length(hostname_has_any) == 0, "-" // match not requested: probably most common case
            , (temp_isSrcHostMatch and temp_isDstHostMatch), "Both" // has to be checked before the individual 
            , temp_isSrcHostMatch, "SrcHostname"
            , temp_isDstHostMatch, "DstHostname"
            , "No match"
    )
    | where ASimMatchingHostname != "No match"
    | project-away temp_* 
    | extend 
        DstUsernameType = 'Simple',
        DstProcessName = tostring(Image),
        DstAppName = tostring(Image),
        DstAppType = 'Process',
        DstUsername = tostring(User), 
        DstProcessId = tostring(ProcessId),
        DstProcessGuid = ProcessGuid
    | project-away
     Image, Initiated
      ;
  let SysmonForWindowsNetworks =
  union OutboundNetworkEvents, InboundNetworkEvents, OutboundNetworkWindowsEvents, inboundNetworkWindowsEvents
      | project-rename 
                Dvc = Computer,
                IpAddr = SrcIpAddr,
                NetworkRuleName = RuleName
    | extend
                EventEndTime = EventStartTime,
                Hostname = case(
                                (SrcHostname == "-" and Dvc == "-"), DstHostname,
                                (DstHostname == "-" and Dvc == "-"), SrcHostname,
                                Dvc),
                DvcHostname = Dvc,
                EventCount = int(1),
                EventVendor = 'Microsoft',
                EventSchemaVersion = '0.2.4',
                EventSchema = 'NetworkSession', 
                EventProduct = 'Sysmon',
                EventType = 'EndpointNetworkSession',
                EventResult = 'Success',
                EventSeverity = 'Informational',
                DvcOs = 'Windows',
                Protocol = toupper(Protocol),
                EventOriginalType = '3', // Set with a constant value to avoid parsing
                SrcIpAddr = IpAddr,
                Src = IpAddr,
                DvcIpAddr  = IpAddr,
                Dst = DstIpAddr,
                SrcDomain = iff(tostring(split(SrcHostname, "\\")[0]) == SrcHostname, "", tostring(split(SrcHostname, "\\")[0])),
                DvcDomain = iff(tostring(split(Dvc, "\\")[0]) == Dvc, "", tostring(split(Dvc, "\\")[0])),
                DstDomain = iff(tostring(split(DstHostname, "\\")[0]) == DstHostname, "", tostring(split(DstHostname, "\\")[0])),
                DvcDomainType = "Windows",
                SrcDomainType = "Windows",
                DstDomainType = "Windows"
      | extend
                SrcHostname = iff( SrcHostname == "-", "", SrcHostname),
                DstHostname = iff( DstHostname == "-", "", DstHostname) // let's make empty values actually empty
      | project-rename 
                NetworkProtocol = Protocol
      | project-away 
                AzureDeploymentID,
                Channel,
                Data,
                Destination*,
                MG,
                ManagementGroupName,
                Message,
                UserName,
                TenantId,
                Task,
                Provider,
                RawEventData,
                Role,
                Source*,
                EventCategory,
                EventID,
                EventLevelName,
                EventLevel,
                EventLog,
                EventOriginId,
                ProcessGuid,
                ProcessId
      ;
      SysmonForWindowsNetworks

Parser:
  Title: Generic DnsEvents
  Version: '0.1'
  LastUpdated: May 11, 2021
Product:
  Name: Source agnostic
Normalization:
  Schema: Dns
  Version: '0.1.1'
References:
- Title: ASIM DNS Schema
  Link: https://aka.ms/AzSentinelDnsDoc
- Title: ASIM
  Link: https://aka.ms/AzSentinelNormalization
Description: |
  ASIM Source Agnostic DNS Parser
ParserName: imDnsBuiltIn
ParserParams:
  - Name: starttime
    Type: datetime
    Default: datetime(null)
  - Name: endtime
    Type: datetime
    Default: datetime(null)
  - Name: srcipaddr
    Type: string
    Default: '*'
  - Name: domain_has_any
    Type: dynamic
    Default: dynamic([])
  - Name: responsecodename
    Type: string
    Default: '*'
  - Name: response_has_ipv4
    Type: string
    Default: '*'
  - Name: response_has_any_prefix
    Type: dynamic
    Default: dynamic([])
  - Name: eventtype
    Type: string
    Default: 'lookup'
Parsers:
  - vimDnsEmpty
  - vimDnsCiscoUmbrella
  - vimDnsInfobloxNIOS
  - vimDnsMicrosoftOMS
  - vimDnsGcp
  - vimDnsCorelightZeek
  - vimDnsMicrosoftSysmon

ParserQuery: |
  let Generic=(starttime:datetime=datetime(null), endtime:datetime=datetime(null) , srcipaddr:string='*' , domain_has_any:dynamic=dynamic([]) , responsecodename:string='*', response_has_ipv4:string='*' , response_has_any_prefix:dynamic=dynamic([]) , eventtype:string='lookup' ){
  let DisabledParsers=materialize(_GetWatchlist('ASimDisabledParsers') | where SearchKey in ('Any', 'imDns') | extend SourceSpecificParser=column_ifexists('SourceSpecificParser','') | distinct SourceSpecificParser);
  let imDnsBuiltInDisabled=toscalar('imDnsBuiltIn' in (DisabledParsers) or 'Any' in (DisabledParsers)); 
  union isfuzzy=true
      vimDnsEmpty
    , vimDnsCiscoUmbrella  ( starttime, endtime, srcipaddr, domain_has_any, responsecodename, response_has_ipv4, response_has_any_prefix, eventtype, (imDnsBuiltInDisabled or('DnsCiscoUmbrella'   in (DisabledParsers) ))
    , vimDnsInfobloxNIOS   ( starttime, endtime, srcipaddr, domain_has_any, responsecodename, response_has_ipv4, response_has_any_prefix, eventtype, (imDnsBuiltInDisabled or('DnsInfobloxNIOS'    in (DisabledParsers) ))
    , vimDnsMicrosoftOMS   ( starttime, endtime, srcipaddr, domain_has_any, responsecodename, response_has_ipv4, response_has_any_prefix, eventtype, (imDnsBuiltInDisabled or('DnsMicrosoftOMS'    in (DisabledParsers) ))
    , vimDnsGcp            ( starttime, endtime, srcipaddr, domain_has_any, responsecodename, response_has_ipv4, response_has_any_prefix, eventtype, (imDnsBuiltInDisabled or('DnsDnsGcp'          in (DisabledParsers) ))
    , vimDnsCorelightZeek  ( starttime, endtime, srcipaddr, domain_has_any, responsecodename, response_has_ipv4, response_has_any_prefix, eventtype, (imDnsBuiltInDisabled or('DnsCorelightZeek'   in (DisabledParsers) ))
    , vimDnsMicrosoftSysmon( starttime, endtime, srcipaddr, domain_has_any, responsecodename, response_has_ipv4, response_has_any_prefix, eventtype, (imDnsBuiltInDisabled or('DnsMicrosoftSysmon' in (DisabledParsers) ))
   };
  Generic( starttime, endtime, srcipaddr, domain_has_any, responsecodename, response_has_ipv4, response_has_any_prefix, eventtype)
ParserQuery_parametrized: |
  let Generic=(starttime:datetime=datetime(null), endtime:datetime=datetime(null) , srcipaddr:string='*' , domain_has_any:dynamic=dynamic([]) , responsecodename:string='*', response_has_ipv4:string='*' , response_has_any_prefix:dynamic=dynamic([]) , eventtype:string='lookup' ){
  let DisabledParsers=materialize(_GetWatchlist('ASimDisabledParsers') | where SearchKey in ('Any', '{ParserName}') | extend SourceSpecificParser=column_ifexists('SourceSpecificParser','') | distinct SourceSpecificParser);
  let {ParserName}BuiltInDisabled=toscalar('{ParserName}BuiltIn' in (DisabledParsers) or 'Any' in (DisabledParsers)); 
  union isfuzzy=true
    vimDnsEmpty
    , {Parsers_i}{Parsers_i.Version}  ( [ParsersParams with default], ({ParserName}BuiltInDisabled or('{Parsers_i}'   in (DisabledParsers) ))
     };
  Generic( starttime, endtime, srcipaddr, domain_has_any, responsecodename, response_has_ipv4, response_has_any_prefix, eventtype)

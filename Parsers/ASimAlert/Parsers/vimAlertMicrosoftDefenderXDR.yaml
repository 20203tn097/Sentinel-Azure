Parser:
  Title: Alert ASIM filtering parser for Microsoft Defender XDR
  Version: '0.1.0'
  LastUpdated: Oct 09, 2024
Product:
  Name: Microsoft Defender XDR
Normalization:
  Schema: Alert
  Version: '0.1'
References:
- Title: ASIM Alert Schema
  Link: https://aka.ms/ASimAlertDoc
- Title: ASIM
  Link: https://aka.ms/AboutASIM
Description: |
  This ASIM parser supports normalizing and filtering the Microsoft Defender XDR logs to the ASIM Alert normalized schema.
ParserName: vimAlertMicrosoftDefenderXDR
EquivalentBuiltInParser: _Im_Alert_MicrosoftDefenderXDR
ParserParams:
  - Name: starttime
    Type: datetime
    Default: datetime(null)
  - Name: endtime
    Type: datetime
    Default: datetime(null)
  - Name: ipaddr_has_any_prefix
    Type: dynamic
    Default: dynamic([])
  - Name: hostname_has_any
    Type: dynamic
    Default: dynamic([])
  - Name: username_has_any
    Type: dynamic
    Default: dynamic([])
  - Name: attacktactics_has_any
    Type: dynamic
    Default: dynamic([])
  - Name: attacktechniques_has_any
    Type: dynamic
    Default: dynamic([])
  - Name: threatcategory_has_any
    Type: dynamic
    Default: dynamic([])
  - Name: alertverdict_has_any
    Type: dynamic
    Default: dynamic([])
  - Name: eventseverity_has_any
    Type: dynamic
    Default: dynamic([])
  - Name: disabled
    Type: bool
    Default: false
ParserQuery: |
    let IndicatorTypeLookup = datatable (EntityType: string, IndicatorType: string)
    [
    "User", "User",
    "Machine", "Host",
    "Process", "Process",
    "File", "File",
    "Ip", "Ip",
    "Url", "Url",
    "RegistryValue", "Registry",
    "CloudLogonSession", "LogonSession",
    "CloudApplication", "Application",
    "Mailbox", "Mailbox",
    "MailMessage", "Email",
    "CloudResource", "Cloud Resource"
    ];
    let AlertSourceAnalyticDetailsLookup = datatable (
        DetectionSource: string,
        AlertSourceAnalyticDetails: string
    )
        [
        "EDR", "EDR",
        "Antivirus", "Antivirus",
        "Microsoft Data Loss Prevention", "DataLossPrevention",
        "Scheduled Alerts", "ScheduledAlerts",
        "Cloud App Security", "CloudApplicationSecurity"
    ];
    let IndicatorAssociationLookup = datatable (EvidenceRole: string, IndicatorAssociation: string)
        [
        "Related", "Associated",
        "Impacted", "Targeted"
    ];
    let RegistryValueTypeLookup = datatable (ValueType: string, RegistryValueType: string)
        [
        "ExpandString", "Reg_Expand_Sz"
    ];
    let AlertVerdictLookup = datatable (AlertVerdict_Custom: string, AlertVerdict: string)
        [
        "Malicious", "True Positive",
        "Suspicious", "True Positive",
        "NoThreatsFound", "Benign Positive"
    ];
    let AttackTacticSet = dynamic(["Exfiltration", "PrivilegeEscalation", "Persistence", "LateralMovement", "Execution", "Discovery", "InitialAccess", "CredentialAccess", "DefenseEvasion", "CommandAndControl", "Impact"]);
    let ThreatCategorySet = dynamic(["Malware", "Ransomware", "Trojan", "Virus", "Worm", "Adware", "Spyware", "Rootkit", "Cryptominor", "Phishing", "Spam", "MaliciousUrl", "Spoofing", "Security Policy Violation", "Unknown", "SuspiciousActivity"]);
    let parser = (starttime: datetime=datetime(null), 
        endtime: datetime=datetime(null), 
        ipaddr_has_any_prefix: dynamic=dynamic([]),
        hostname_has_any: dynamic=dynamic([]),
        username_has_any: dynamic=dynamic([]),
        attacktactics_has_any: dynamic=dynamic([]),
        attacktechniques_has_any: dynamic=dynamic([]),
        threatcategory_has_any: dynamic=dynamic([]),
        alertverdict_has_any: dynamic=dynamic([]),
        eventseverity_has_any: dynamic=dynamic([]),
        disabled: bool=false) {
        AlertEvidence
        | where not(disabled)
        | where (isnull(starttime) or TimeGenerated >= starttime)
            and (isnull(endtime) or TimeGenerated <= endtime)
            and ((array_length(ipaddr_has_any_prefix) == 0) or (has_any_ipv4_prefix(DeviceId, ipaddr_has_any_prefix)) or (has_any_ipv4_prefix(tostring(AdditionalFields.Host.IpInterfaces[0].Address), ipaddr_has_any_prefix)) or (has_any_ipv4_prefix(RemoteIP, ipaddr_has_any_prefix)))
            and ((array_length(hostname_has_any) == 0) or (DeviceName has_any (hostname_has_any)) or (tostring(AdditionalFields.Host.NetBiosName) has_any (hostname_has_any)))
            and ((array_length(username_has_any) == 0) or (AccountUpn has_any (username_has_any)) or (tostring(AdditionalFields.Account.UserPrincipalName) has_any (username_has_any)))
            and ((array_length(attacktactics_has_any) == 0) or (Categories has_any (attacktactics_has_any)))
            and ((array_length(attacktechniques_has_any) == 0) or (AttackTechniques has_any (attacktechniques_has_any)))
            // ThreatCategory filtering done later in the parser
            // AlertVerdict filtering done later in the parser
            and ((array_length(eventseverity_has_any) == 0)) // EventSeverity not set in this parser.
        // Mapping Alert Fields
        | extend 
            AlertId = AlertId,
            AlertName = Title,
            AlertSource = ServiceSource,
            AlertVerdict_Custom = tostring(AdditionalFields.ThreatAnalysisSummary[0].Verdict),
            AlertVerdictDate = todatetime(AdditionalFields.ThreatAnalysisSummary[0].AnalysisDate),
            AttackTactics = iff(Categories has_any (AttackTacticSet), replace(@"[\[\]\""]", "", Categories), ""),
            AlertOriginalStatus = tostring(AdditionalFields.LastRemediationState),
            AlertStatus = iif(isnotempty(AdditionalFields.LastRemediationState), iif(AdditionalFields.LastRemediationState == "Active", "Active", "Closed"), "")
        | lookup AlertVerdictLookup on AlertVerdict_Custom
        // Filter for AlertVerdict
        | where ((array_length(alertverdict_has_any) == 0) or (AlertVerdict has_any (alertverdict_has_any)))
        | lookup IndicatorTypeLookup on EntityType
        | lookup IndicatorAssociationLookup on EvidenceRole
        | lookup AlertSourceAnalyticDetailsLookup on DetectionSource
        // Mapping Threat Fields
        | extend
            ThreatCategory = iif(Categories has_any (ThreatCategorySet), replace(@"[\[\]\""]", "", Categories), ""),
            ThreatIsActive = iif(isnotempty(AdditionalFields.LastRemediationState), iif(tostring(AdditionalFields.LastRemediationState) == "Active", True, False), bool(null))
        // Filter for ThreatCategory
        | where ((array_length(threatcategory_has_any) == 0) or (ThreatCategory has_any (threatcategory_has_any)))
        // Mapping User Entity
        | extend 
            UserId = coalesce(AccountObjectId, tostring(AdditionalFields.Account.AadUserId)),
            UserSid = coalesce(AccountSid, tostring(AdditionalFields.Account.Sid)),
            Username = coalesce(AccountUpn, tostring(AdditionalFields.Account.UserPrincipalName)),
            SessionId = tostring(AdditionalFields.SessionId),
            UserScopeId = tostring(AdditionalFields.AadTenantId)
        // Mapping Device Entity
        | extend 
            DvcId = coalesce(DeviceId, tostring(AdditionalFields.Host.MachineId)),
            DvcIpAddr = coalesce(LocalIP, tostring(AdditionalFields.Host.IpInterfaces[0].Address), RemoteIP),
            DvcOs = tostring(coalesce(AdditionalFields.OSFamily, AdditionalFields.Host.OSFamily)),
            DvcOsVersion = tostring(coalesce(AdditionalFields.OSVersion, AdditionalFields.Host.OSVersion)),
            DeviceName = coalesce(DeviceName, tostring(AdditionalFields.Host.NetBiosName)),
            DvcScopeId = coalesce(tostring(split(AdditionalFields.AzureID, "/")[2]), (tostring(split(AdditionalFields.ResourceId, "/")[2])))
        | invoke _ASIM_ResolveDvcFQDN("DeviceName")
        | extend Hostname = DvcHostname
        // Mapping IP Entity
        | extend 
            IpAddr = RemoteIP,
            GeoCity = AdditionalFields.Location.City,
            GeoCountry = AdditionalFields.Location.CountryCode,
            GeoLatitude = AdditionalFields.Location.Latitude,
            GeoLongitude = AdditionalFields.Location.Longitude,
            GeoRegion = AdditionalFields.Location.State
        // Mapping Process Entity
        | extend 
            ProcessId = AdditionalFields.ProcessId,
            ProcessCommandLine,
            ProcessName = iif(IndicatorType == "Process", iif(isnotempty(FolderPath) and isnotempty(FileName), strcat(FolderPath, '\\', FileName), FileName), ""),
            ProcessFileCompany = AdditionalFields.Publisher,
            // Parent Process Fields
            ParentProcessId = AdditionalFields.ParentProcess.ProcessId,
            ParentProcessCommandLine = AdditionalFields.ParentProcess.CommandLine,
            //ParentProcessName = strcat (AdditionalFields.ParentProcess.ImageFile.Directory, "\\", AdditionalFields.ParentProcess.ImageFile.Name),
            ParentProcessName = iif(IndicatorType == "Process", iif(isnotempty(AdditionalFields.ParentProcess.ImageFile.Directory) and isnotempty(AdditionalFields.ParentProcess.ImageFile.Name), strcat (AdditionalFields.ParentProcess.ImageFile.Directory, "\\", AdditionalFields.ParentProcess.ImageFile.Name), coalesce(AdditionalFields.ParentProcess.ImageFile.Name, AdditionalFields.ParentProcess.FriendlyName)), ""),
            ParentProcessSHA1 = AdditionalFields.ParentProcess.ImageFile[0].SHA1,
            ParentProcessSHA256 = AdditionalFields.ParentProcess.ImageFile[2].SHA256,
            ParentProcessMD5 = AdditionalFields.ParentProcess.ImageFile[1].MD5
        // Mapping File Entity
        | extend 
            FileName,
            FileDirectory = FolderPath,
            FilePath = iff(isnotempty(FolderPath) and isnotempty(FileName), strcat(FolderPath, '\\', FileName), FileName),
            FileSHA1 = SHA1,
            FileSHA256 = SHA256,
            FileMD5 = AdditionalFields.FileHashes[1].Value,
            FileSize = FileSize
        // Mapping Url Entity
        | extend 
            Url = RemoteUrl
        // Mapping Registry Entity
        | extend 
            RegistryKey,
            RegistryValue = RegistryValueName,
            RegistryValueData,
            ValueType = tostring(AdditionalFields.ValueType)
        | lookup RegistryValueTypeLookup on ValueType
        // Mapping Application Entity
        | extend 
            HttpUserAgent = AdditionalFields.UserAgent,
            AppId = ApplicationId,
            AppName = Application
        // Mapping Email Entity
        | extend 
            EmailMessageId = NetworkMessageId,
            EmailSubject
        // Mapping common event fields
        | extend
            EventSubType = "Threat", // All events in AlertEvidence contains threat info
            EventEndTime = TimeGenerated,
            EventStartTime = TimeGenerated,
            EventProduct = 'Defender XDR',
            EventVendor = 'Microsoft',
            EventSchemaVersion = '0.1',
            EventType = 'Alert',
            EventUid = _ItemId
        | project-away
            Title,
            Categories,
            EntityType,
            EvidenceRole,
            DetectionSource,
            ServiceSource,
            ThreatFamily,
            RemoteIP,
            RemoteUrl,
            AccountName,
            AccountDomain,
            DeviceName,
            LocalIP,
            AdditionalFields,
            AlertVerdict_Custom
    };
    parser(
        starttime = starttime, 
        endtime = endtime, 
        ipaddr_has_any_prefix = ipaddr_has_any_prefix,
        hostname_has_any = hostname_has_any,
        username_has_any = username_has_any,
        attacktactics_has_any = attacktactics_has_any,
        attacktechniques_has_any = attacktechniques_has_any,
        threatcategory_has_any = threatcategory_has_any,
        alertverdict_has_any = alertverdict_has_any,
        eventseverity_has_any = eventseverity_has_any,
        disabled = disabled
    )

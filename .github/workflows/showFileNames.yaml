# name: CIBuild

# on:
#   pull_request:

# jobs:
#   build:
#     runs-on: ubuntu-latest | windows-latest | macos-latest
#     name: Test changed-files
#     steps:
#       - uses: actions/checkout@v3
#         with:
#           fetch-depth: 0  # OR "2" -> To retrieve the preceding commit.

#       # - name: Set up Python 3.7
#       #   uses: actions/setup-python@v1
#       #   with:
#       #     python-version: "3.7"

#       # - uses: actions/checkout@v1

#       # - name: Fetch action
#       #   id: pl
#       #   uses: Rishabh510/Path-lister-action@master
#       #   with:
#       #     path: "./Solutions/Alibaba Cloud/"
#       #     type: ".json"

#       # - name: Output results
#       #   run: |
#       #     echo "Found ${{ steps.pl.outputs.path_count }} file(s) with this extension:"
#       #     for i in ${{ steps.pl.outputs.paths }}; do
#       #     echo "this is the result $i"
#       #     done

#       - id: files
#         uses: jitterbit/get-changed-files@v1
#         with:
#           format: 'json'
#       - run: |
#           mapfile -d ',' -t all_files < <(printf '%s,' '${{ steps.files.outputs.all }}')
#           for changed_file in ${all_files[@]}; do
#             echo "${changed_file}"
#           done
        
#       - id: modified-files
#         uses: jitterbit/get-changed-files@v1
#         with:
#           format: 'csv'
#       - run: |
#           mapfile -d ',' -t all_files < <(printf '%s,' '${{ steps.files.outputs.all }}')
#           for file in "${all_files[@]}"; do
#             echo "Do something with this ${file}."
#           done

#       - uses: actions/checkout@v2
#         with:
#           # Checkout as many commits as needed for the diff
#           fetch-depth: 0

#       - shell: pwsh
#         # Give an id to the step, so we can reference it later
#         id: check_file_changed
#         run: |
#           # Diff HEAD with the previous commit
#           $diff = git diff --diff-filter=d --name-only HEAD^ HEAD
#           Write-Host "List of files added/modified/changed/deleted: $diff"

#           $newDataConnectorFilesWithoutExcludedFiles = @()

#           # Check if a file under docs/ or with the .md extension has changed (added, modified, deleted)
#           $SourceDiff = $diff | ForEach-Object {
#             Write-Output "Processing line $_"
#             $file = Get-ChildItem -Path $_ -File

#             $fileValue = (($file.DirectoryName).Split("\")[-1])
#             Write-Host "FileValue: $fileValue"

#             $solutionNameWithOtherPath = $fileValue.SubString($fileValue.LastIndexOf("Solutions") + 10)
#             Write-Host "path : $solutionNameWithOtherPath"
#             if ($solutionNameWithOtherPath -ne '' -or $solutionNameWithOtherPath -ne $null)
#             {
#               $headers = $solutionNameWithOtherPath -split '/', 3
#               Write-Host "list of headers: $headers"
#               Write-Host "header value: $headers[0]"
#               if ($headers[0] -ne $null)
#               {
#                 $solutionName = $headers[0]
#                 Write-Host "sol name: $solutionName"
#               }
#             }
            
#             Write-Host "filtered solution name: $solutionName"
#             $indexOfSolutionFolderName = $fileValue.LastIndexOf("Solutions")
#             $indexOfParsersFolderName = $fileValue.LastIndexOf("/Parsers")
#             $indexOfDataConnectorsFolderName = $fileValue.LastIndexOf("$solutionName/DataConnectors")
#             $indexOfDataConnectorsWithSpaceFolderName = $fileValue.LastIndexOf("/Data Connectors")

#             Write-Host "solution index: $indexOfSolutionFolderName"
#             Write-Host "parser index: $indexOfParsersFolderName"
#             Write-Host "dataconnector index: $indexOfDataConnectorsFolderName"

#             if ($indexOfSolutionFolderName -gt 0)
#             {
#               $getsolutionFolderName = $fileValue.SubString($indexOfSolutionFolderName  + 10)
#               Write-Host "Get Solution Name : $getsolutionFolderName"
#               $lastIndex = $getsolutionFolderName.indexOf("/")

#               $finalValueSolutionName = $getsolutionFolderName.SubString(0, $lastIndex)
#               Write-Host "first value $finalValue"
#             }


#             $filesList = git ls-files

#             if($indexOfParsersFolderName -gt 0)
#             {           
#               $valueOfSolutionName = $fileValue.SubString($indexOfSolutionFolderName)
#               Write-Host "Solution Folder Name : $valueOfSolutionName"

#               $parserFolderResult = $filesList -match $valueOfSolutionName
#             }

#             if($indexOfDataConnectorsFolderName -gt 0 -And $solutionName -ne $null)
#             {           
#               $valueOfSolutionName = $fileValue.SubString($indexOfDataConnectorsFolderName)
#               Write-Host "DataConnector Folder Name : $valueOfSolutionName"

#               $dataConnectorFolderResult = $filesList -match $valueOfSolutionName
#             }

#             $hasParserFolderChanged = $indexOfDataConnectorsFolderName -gt 0
#           }

#           Write-Host "Parser Result: $parserFolderResult"
#           Write-Host "DataConnector Result: $dataConnectorFolderResult"
#           Write-Host "==============================="
#           if ($parserFolderResult -ne $null)
#           {
#             $jsonParserFiles = $parserFolderResult | ConvertTo-Json -AsArray
#             Write-Host "parserfiles: $jsonParserFiles"

#             if ($jsonParserFiles -ne $null)
#             {
#               Write-Host "json string for parser files: $jsonParserFiles"
#             }
#           }

#           if ($dataConnectorFolderResult -ne $null)
#           {
#             $jsonDataConnectorFiles = $dataConnectorFolderResult | ConvertTo-Json -AsArray
#             Write-Host "Dataconnect: $jsonDataConnectorFiles"
#             if ($jsonDataConnectorFiles -ne $null)
#             {
#               Write-Host "json string for dataconnector files: $jsonDataConnectorFiles"
#             }

#             $libfiles = "(\.json)$"
#             $libfilesregex = [string]::Join('|', $libfiles)
#             $newresultInJson = $dataConnectorFolderResult -match $libfilesregex
#             #Write-Host "New Result $newresultInJson"

#             foreach($item in $newresultInJson)
#             {
#               $hostFileExist = $item -match "host.json"
#               $proxiesFileExist = $item -match "proxies.json"
#               $azureDeployFileExist = $item -match "azureDeploy"
#               $functionFileExist = $item -match "function.json"

#               if ($hostFileExist -or $proxiesFileExist -or $azureDeployFileExist -or $functionFileExist)
#               {}
#               else
#               {
#                 $newDataConnectorFilesWithoutExcludedFiles += $item
#                 Write-Host "file name: $item"
#               }
#             }
#           }

#           Write-Host "Solution Name: $finalValueSolutionName"
#           Write-Host "Final dataconnector data: $newDataConnectorFilesWithoutExcludedFiles"
#           $resultDataConnector = $newDataConnectorFilesWithoutExcludedFiles | ConvertTo-Json -AsArray
#           Write-Host "====================================================="
#           Write-Host "Final DataConnector JSON: $resultDataConnector"
          
#           # Set the output named "docs_changed"
#           Write-Host "::set-output name=parser_folder_files_changed::$hasParserFolderChanged"

#           # $isSuccessTask1 = True
#           # Write-Host "##vso[task.setvariable variable=isSuccessTask1;]$isSuccessTask1"
          
#           Write-Host "::set-output name=isSuccessTask::True"
#           #Write-Host "::set-output name=parserJson::$jsonParserFiles"
#           # Write-Host "::set-output name=dataConnectorJson::$resultDataConnector"

#           Write-Host "Set environment variable to ($env:isSuccessTask)"

#       - shell: pwsh
#         if: steps.check_file_changed.outputs.parser_folder_files_changed == 'True'
#         run: |
#           Write-Host "In function"

#       - id: JSONtovariables1
#         if: steps.check_file_changed.outputs.isSuccessTask == 'True'
#         uses: antifree/json-to-variables@v1.0.1
#         with:
#           filename: "./Sample Data/sampleDataFile.json"
#           prefix: test
#       - name: Show output
#         run: |
#           echo "The time was ${{ env.test_Name }}, ${{ env.test_Version }}, ${{ env.test_Author }}"
#           echo "parserFinalJson: $parserJson"
#           echo "dataConnectorFinalJson: $dataConnectorJson"


